// Matrix.h: interface for the CMatrix class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MATRIX_H__9089E226_1BBD_478C_B56E_B600897DFE0D__INCLUDED_)
#define AFX_MATRIX_H__9089E226_1BBD_478C_B56E_B600897DFE0D__INCLUDED_

#if _MSC_VER > 1000

#endif // _MSC_VER > 1000


class CMatrix  
{
public:

	void SetMatrixValue(const int &iHauteurStart, const int &iLargeurStart, CMatrix m_Matrix);

	CMatrix();
	virtual ~CMatrix();

	void CMatrix::moins();

	const double GetValuePos(const int &y, const int &x);

	void SetValuePos(const int &y, const int &x, const double &value);

	//Uniquement valable pour les matrix carrés

	CMatrix GetMatrixInverse();


	//Uniquement valable pour les matrix carrés
	void SetMatrixInverse();


	CMatrix ArrayMulti (const CMatrix& b);


	void ArrayLocalMulti(const CMatrix& b);

	void ArrayLocalAdd(const CMatrix& b);

	void ArrayLocalSqrt();

	CMatrix ArraySqrt(const CMatrix& b);

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	CMatrix ArrayDivi(const CMatrix& b);

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	void ArrayLocalDivi(const double& b);
	
	CMatrix(const CMatrix & Source);

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	CMatrix(const int &M, const int &N);


		/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	void zeros(const int &M, const int &N);
	void ones(const int &iColDepart, const int &iLigneDepart,const int &iSize);
	void ones(const int &M, const int &N);

	void show();
	void prime();
	void freqspace(const int &iTaille);

	int Prod();

	double Value();

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	const int & GetTheMValue() const
	{
		return m_iM;
	};

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	const int & GetNValue() const 
	{
		return m_iN;
	};

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	const int & GetLValue() const
	{
		return m_iL;
	};

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	double * GetDataPt() const 
	{
		return X;
	};

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	double * GetDataPt2() 
	{
		return X;
	};

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	void fftshift();


	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	CMatrix& operator = (const CMatrix& a);

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	CMatrix operator * (const double& b);

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	CMatrix operator / (const double& b);

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	CMatrix operator / (const CMatrix& b);

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	CMatrix operator + (const CMatrix& b);

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	void Div(const double& b);

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	void rot90(const int &iNb = 1);

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////


	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

	CMatrix operator * (CMatrix& b);

	void AllocationMemoire(const int &M, const int &N);

	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////

private:

	void AllocationMemoire();
	void AllocationMemoire(const long &iSize);
	void DesAllocationMemoire();


	void CMatrix::ludcmp(CMatrix &m_MatrixSource, int * &indx, double &d);
	void CMatrix::lubksb(CMatrix &m_MatrixSource, int * indx, double * b);

	void inverse(double * & data,const int &iRow, const int &iCol);
	inline void deplacement(double * & data,const int &iPosDepart,const int &iPosFin);
	void LocalPrime(const int &iRow, const int &iCol);
	void rotate90(double * &data,int &iRow, int &iCol);

	int m_iM; //Hauteur
	int m_iN; //Largeur
	int m_iL;
	int iAllocationType;

	double * X;


};




#endif // !defined(AFX_MATRIX_H__9089E226_1BBD_478C_B56E_B600897DFE0D__INCLUDED_)

